<!DOCTYPE html>
<html>

<head>
    <link rel="Stylesheet" type="text/css" href="style.css">
    <title>inverttree</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>

<body>

    <p>
        there are two methods
        First one is my method and second one is algoexpert method in my method I have just iterated oppositely that is
        not left to right but right to left and kept storing the value of the current node in another tree and at last
        printing new tree.
        T.C. O(N)
        S.C. O(d) d=depth
        Second method is based on bfs method.They are also following the same method instead of storing the nodes value
        in another tree they are storing them in a queue and just printing it.
        T.C.O(N)
        S.C.O(N)
    </p>
    <table>
        <tr>
            <td>

                <head>
                    <style>
                        .keyword {
                            color: rgb(0, 0, 255);
                        }

                        .comment {
                            color: rgb(0, 128, 0);
                        }

                        .pp {
                            color: rgb(0, 0, 255);
                        }
                    </style>
                    <pre style="font-family:courier;font-size:10pt"><span class=pp>#include</span> &lt;cstdio&gt;
<span class=pp>#include</span> &lt;iostream&gt;
<span class=pp>#include</span> &lt;vector&gt;

<span class=keyword>using</span> <span class=keyword>namespace</span> std;

<span class=keyword>typedef</span> <span class=keyword>struct</span> node{
    <span class=keyword>int</span> data;
    <span class=keyword>struct</span> node *left=nullptr,*right=nullptr;
}node;

<span class=keyword>inline</span> node *btinsert(){
    node *curnode;
    curnode=<span class=keyword>new</span> node;
    printf(&quot;Enter data:: &quot;);
    scanf(&quot;%d&quot;,&amp;curnode-&gt;data);
    <span class=keyword>if</span>(curnode-&gt;data==-1){
        <span class=keyword>return</span> nullptr;
    }
    curnode-&gt;left=btinsert();
    curnode-&gt;right=btinsert();
    <span class=keyword>return</span> curnode;
}

<span class=keyword>inline</span> node *mymethodinverttree(node *curnode){
    <span class=keyword>if</span>(curnode==nullptr){
        <span class=keyword>return</span> nullptr;
    }
    node *newnode;
    newnode=<span class=keyword>new</span> node();
    newnode-&gt;data=curnode-&gt;data;
    newnode-&gt;left=mymethodinverttree(curnode-&gt;right);
    newnode-&gt;right=mymethodinverttree(curnode-&gt;left);
    <span class=keyword>return</span> newnode;
}

<span class=keyword>inline</span> <span class=keyword>bool</span> algoguymtd(node *curnode,vector&lt;<span class=keyword>int</span>&gt; &amp;storeprcs){
    <span class=keyword>if</span>(curnode==nullptr){
        <span class=keyword>return</span> 0;
    }
    storeprcs.push_back(curnode-&gt;data);
    algoguymtd(curnode-&gt;right,storeprcs);
    algoguymtd(curnode-&gt;left,storeprcs);
    <span class=keyword>return</span> 1;
}

<span class=keyword>inline</span> <span class=keyword>bool</span> displaybst(node *curnode){
    <span class=keyword>if</span>(curnode==nullptr) <span class=keyword>return</span> 0;
    printf(&quot;%d &quot;,curnode-&gt;data);
    displaybst(curnode-&gt;left);
    displaybst(curnode-&gt;right);
    <span class=keyword>return</span> 1;
}


<span class=keyword>int</span> main(){
    vector&lt;<span class=keyword>int</span>&gt; inverttree;
    node *root=btinsert();
    displaybst(root);
    node *root2=mymethodinverttree(root);
    printf(&quot;\n&quot;);
    displaybst(root2);
    algoguymtd(root,inverttree);
    printf(&quot;\n&quot;);
    <span class=keyword>for</span>(<span class=keyword>auto</span> i:inverttree){
        cout&lt;&lt;i&lt;&lt;&quot; &quot;;
    }
    cout&lt;&lt;endl;
}
</pre>
            </td>
        </tr>
    </table>
</body>

</html>