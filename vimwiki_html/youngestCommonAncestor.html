<!DOCTYPE html>
<html>

<head>
    <link rel="Stylesheet" type="text/css" href="style.css">
    <title>youngestcommonancestor</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>

<body>

    <p>
        In this problem, we have to find the largest youngest commom ancestor for 1,2 or more nodes in a graph and print
        the youngest ancestor.
        T.C. O(d=depth)
        S.C. O(1)
        my method
        T.C. O(d)
        S.C. O(d)
    </p>
    <table>
        <tr>
            <td>

                <head>
                    <style>
                        .keyword {
                            color: rgb(0, 0, 255);
                        }

                        .comment {
                            color: rgb(0, 128, 0);
                        }

                        .pp {
                            color: rgb(0, 0, 255);
                        }
                    </style>
                    <pre style="font-family:courier;font-size:10pt"><span class=pp>#include</span> &lt;algorithm&gt;
<span class=pp>#include</span> &lt;cstdio&gt;
<span class=pp>#include</span>&lt;iostream&gt;
<span class=pp>#include</span> &lt;vector&gt;

<span class=keyword>using</span> <span class=keyword>namespace</span> std;

<span class=keyword>class</span> AncestralTree{
    <span class=keyword>public</span>:
        <span class=keyword>char</span> name;
        AncestralTree* ancestor;

        AncestralTree(<span class=keyword>char</span> name){
            <span class=keyword>this</span>-&gt;name=name;
            <span class=keyword>this</span>-&gt;ancestor=NULL;
        }

        <span class=keyword>void</span> addAsAncestor(vector&lt;AncestralTree*&gt; descendants);
};

<span class=keyword>inline</span> <span class=keyword>void</span> mymethod(){
    vector&lt;vector&lt;<span class=keyword>char</span>&gt;&gt; tree{
            {'A','B','G'},
            {'A','B','H','O'},
            {'A','B','H','P','T'},
            {'A','B','H','P','U'},
            {'A','B','H','Q'},
            {'A','B','H','R','V','W'},
            {'A','B','H','R','V','X','Z'},
            {'A','B','H','R','V','Y'},
            {'A','B','I'},
            {'A','C','J'},
            {'A','D','K'},
            {'A','D','L'},
            {'A','E'},
            {'A','F','M'},
            {'A','F','N'}

    };
    vector&lt;vector&lt;<span class=keyword>char</span>&gt;&gt; requiredpaths;
    vector&lt;<span class=keyword>char</span>&gt; descendants{'I','T'};
    vector&lt;int64_t&gt; pos(descendants.size());
    <span class=keyword>for</span>(<span class=keyword>auto</span> z:descendants)
        <span class=keyword>for</span>(<span class=keyword>auto</span> i:tree){
            <span class=keyword>for</span>(<span class=keyword>auto</span> j:i){
                <span class=keyword>if</span>(j==z){
                    requiredpaths.push_back(i);
                    <span class=keyword>break</span>;
                }
            }
    }
    <span class=keyword>for</span>(int64_t i=0;i&lt;descendants.size();i++){
        pos[i]=(find(requiredpaths[i].begin(),requiredpaths[i].end(),descendants[i])-requiredpaths[i].begin());
    }
    pos[1]=pos[0]=min(pos[0],pos[1]);
    <span class=keyword>while</span>(requiredpaths[0][pos[0]]!=requiredpaths[1][pos[1]]){
        pos[0]--;
        pos[1]--;
    }
    printf(&quot;Youngest common ancestor is %c&quot;,requiredpaths[0][pos[0]]);
}

<span class=keyword>int</span> main(){
}
</pre>
            </td>
        </tr>
    </table>
</body>

</html>